% \VignetteIndexEntry{polyRAD tutorial}
% \VignettDepends{polyRAD}

\documentclass{article}

\usepackage{hyperref}

\title{polyRAD tutorial}
\date{\today}
\author{Lindsay V. Clark \\ University of Illinois, Urbana-Champaign}

\begin{document}
\SweaveOpts{concordance=TRUE}

\maketitle

\section{Introduction}

polyRAD is an R package that assists with genotype calling from DNA sequence
datasets such as genotyping-by-sequencing (GBS) or restriction site-associated
DNA sequencing (RAD) in polyploids and diploids.  Genotype likelihoods are 
estimated from allelic read
depth, genotype prior probabilities are estimated from population parameters,
and then genotype posterior probabilities are estimated from likelihoods and
prior probabilities.  Posterior probabilities can be used directly in 
downstream analysis, converted to weighted mean genotypes for analyses
of additive genetic effects, or used for export of the most probable genotypes
for analyses that require discrete genotypic data.

Analyses in polyRAD center around objects of an S3 class called ``RADdata''.
A single ``RADdata'' object contains the entire dataset of read depth and 
locus information, as well as parameters that are estimated during the
course of analysis.

\section{Summary of available functions}

For any function named in this section, see its help page for more information.
(For example by typing \texttt{?VCF2RADdata} into the R console.)

Several functions are available for import of read depth data and (optionally)
alignment information into a RADdata object:

\begin{itemize}
\item \texttt{VCF2RADdata}
\item \texttt{readTagDigger}
\item \texttt{readStacks1}
\item \texttt{readHMC}
\end{itemize}

More generally, the \texttt{RADdata} function is used for constructing RADdata
objects; see the help page for that function for more information on what 
data are needed.

Several pipelines are available for genotype estimation, depending on how the 
population is structured (i.e. what the genotype prior probabilities should be.):

\begin{itemize}
\item \texttt{PipelineMapping2Parents}
\item \texttt{IterateHWE}
\item \texttt{IteratePopStruct}
\end{itemize}

Lastly, for exporting the estimated genotypes to other software:

\begin{itemize}
\item \texttt{ExportGAPIT}
\item \texttt{Export\_rrBLUP\_Amat}
\item \texttt{Export\_rrBLUP\_GWAS}
\end{itemize}

If you need continuous numerical genotypes exported in some other format, see 
\texttt{GetWeightedMeanGenotypes}.  Also, \texttt{GetLikelyGen} returns the 
most likely genotypes for a single sample.

\section{Estimating genotype probabilities in a mapping population}

In this example, we'll import some data from an F1 mapping population
of \emph{Miscanthus sinensis} that were output by the 
\href{https://doi.org/10.1371/journal.pgen.1003215}{UNEAK} pipeline.
These data are from a study by Liu \emph{et al.} 
(2015; \href{http://dx.doi.org/10.1111/gcbb.12275}{doi:10.1111/gcbb.12275};
data available at \url{http://hdl.handle.net/2142/79522}), and can be
found in the ``doc'' folder of the polyRAD installation.
\emph{Miscanthus} is an ancient tetraploid that has undergone diploidization.
Given the ability of the UNEAK pipeline to filter paralogs, we expect most
loci to behave in a diploid fashion, but some may behave in an allotetraploid
fashion.

We'll start by loading polyRAD and importing the data into a ``RADdata''
object.  The \texttt{possiblePloidies} argument indicates the expected
inheritance modes: diploid (2) and allotetraploid (2 2).

<<>>=
library(polyRAD)
mydata <- readHMC("HapMapClareMap1subset.hmc.txt",
                  possiblePloidies = list(2, c(2, 2)))
mydata
@

We can view the imported taxa names (subsetted here for space).

<<>>=
GetTaxa(mydata)[c(1:10,293:299)]
@

All names starting with ``Map'' are progeny.  ``Kaskade-Justin'' and
``Zebrinus-Justin'' are the parents.  ``IGR-2011-001'', ``p196-150A-c'',
and ``p877-348-b'' aren't part of the population, but were doubled
haploid lines that were used to screen for paralogous markers.  We can
tell polyRAD which taxa are the parents; since this is an F1 population
it doesn't matter which is ``donor'' and which is ``recurrent''.

<<>>=
mydata <- SetDonorParent(mydata, "Kaskade-Justin")
mydata <- SetRecurrentParent(mydata, "Zebrinus-Justin")
@

Now we can run the pipeline.
We'll specify that we don't want to include the parents or doubled haploid
lines in the estimation of allele frequencies or evaluation of genotype
freqnecies (\texttt{excludeTaxa} argument). The
\texttt{allowedDeviation} argument indicates how different the apparent
allele frequency (based on read depth ratios) can be from an expected
allele frequency (determined based on ploidy and mapping population type) 
and still be classified as that allele frequency. The default settings assume an
F1 population, but the population type can be adjusted using the
\texttt{n.gen.backcrossing}, \texttt{n.gen.intermating}, and
\texttt{n.gen.selfing} arguments.


<<>>=
mydata <- PipelineMapping2Parents(mydata, 
                                  freqExcludeTaxa = c("Kaskade-Justin", 
                                                      "Zebrinus-Justin",
                                                     "IGR-2011-001",
                                                     "p196-150A-c", 
                                                     "p877-348-b"),
                                  freqAllowedDeviation = 0.06,
                                  useLinkage = FALSE)
@

We can examine the allele frequencies.
Allele frequencies that fall outside of the expected ranges will be 
recorded as \texttt{NA}.

<<>>=
table(mydata$alleleFreq)
@

Genotype likelihood is also stored in the object for each possible
genotype at each locus, taxon, and ploidy.  This is the probability
of seeing the observed distribution of reads.

<<>>=
mydata$alleleDepth[3,1:10]
mydata$genotypeLikelihood[[1]][,3,1:10]
mydata$genotypeLikelihood[[2]][,3,1:10]
@

Above, for one individal (Map1-001), we see its read depth at the
first ten alleles (first five loci), followed by the genotype likelihoods
under diploid and tetraploid models.  For example, at locus TP29 we see
that homozygosity for allele 0 is the most likely, although heterozygosity
is not impossible, and homozygosity for allele 1 could happen in the very,
very unlikely event that all eight of the reads are due to contamination.
At TP37, heterozygosity is by far the most likely state, and if there
is tetraploidy there are probably one or two copies of allele 0 rather than
three copies.

The prior genotype probabilities (expected genotype distributions) are also
stored in the object for each possible ploidy.  These distributions are estimated based
on the most likely parent genotypes.  Low confidence parent genotypes
can be ignored by increasing the \texttt{minLikelihoodRatio} argument to
\texttt{PipelineMapping2Parents}.

<<>>=
mydata$priorProb[[1]][,1:10]
mydata$priorProb[[2]][,1:10]
@

Here we see some pretty big differences under the diploid and
allotetrapliod models.  For example, if TP29 is behaving in a diploid
fashion we expect F2-like segregation since both parents were 
heterozygous.  However, if TP29 is behaving in an allotetraploid
fashion, we expect that both parents are homozygous at differing 
paralogous loci, resulting in no segregation.

Now we want to determine which ploidy is the best fit for each locus.
This is done by comparing genotype prior probabilities to
genotype likelihoods and estimating a $\chi^2$ statistic.  Lower
values indicate a better fit.

<<>>=
mydata$ploidyChiSq[,1:10]
@

We can make a plot to get an overall sense of how well the markers
fit the diploid versus tetraploid model.

<<fig=TRUE>>=
plot(mydata$ploidyChiSq[1,], mydata$ploidyChiSq[2,], 
     xlab = "Chi-squared for diploid model",
     ylab = "Chi-squared for tetraploid model")
abline(a = 0, b = 1, col = "red")
@

Alleles above the red line fit the diploid model better, and alleles
below the red line fit the tetraploid model better.

Now we'll examine the posterior genotype probabilities.  These are still
estimated separately for each ploidy.

<<>>=
mydata$posteriorProb[[1]][,3,1:10]
mydata$posteriorProb[[2]][,3,1:10]
@

We can export the results for use in downstream analysis.  The function
below weights possible ploidies for each allele based on the results
in \texttt{mydata\$ploidyChiSq}, and for each taxon outputs a continuous,
numerical genotype that is the mean of all possible genotypes weighted
by genotype posterior probabilities.  By default, one allele per locus
is discarded in order to avoid mathematical singularities in downstream
analysis.  The continuous genotypes also range from zero to one by default,
which can be changed with the \texttt{minval} and \texttt{maxval} arguments.

<<>>=
mywm <- GetWeightedMeanGenotypes(mydata)
mywm[3:6, 1:10]
@

Note that the parent weighted mean genotypes are not necessarily correct,
since they were estimated using the genotype priors for the progeny.
We can view parent genotypes with \texttt{GetLikelyGen}, which was used
internally by \texttt{AddGenotypePriorProb\_Mapping2Parents} to estimate
the parent genotypes.

<<>>=
kaskadeGen <- GetLikelyGen(mydata, "Kaskade-Justin")
zebrinusGen <- GetLikelyGen(mydata, "Zebrinus-Justin")
kaskadeGen[,1:10]
zebrinusGen[,1:10]
@

To subset parent genotypes in order to match the progeny genotypes:

<<>>=
kaskadeGenSubset <- sweep(kaskadeGen[,-OneAllelePerMarker(mydata)],
                          1, c(2,4), "/")
zebrinusGenSubset <- sweep(zebrinusGen[,-OneAllelePerMarker(mydata)],
                          1, c(2,4), "/")
kaskadeGenSubset[,1:10]
zebrinusGenSubset[,1:10]
@

\section{Estimating genotype probabilities in a diversity panel}

Pipelines in polyRAD for processing a diversity panel (i.e. a germplasm
collection, a set of samples collected in the wild, or a panel for
genome-wide association analysis or genomic prediction) use iterative
algorithms.  Essentially, allele frequencies are re-estimated with each
iteration until convergence is reached.

Here we'll import a RAD-seq dataset from a large collection of wild and
ornamental \textit{Miscanthus} from Clark \textit{et al.} (2014;
\href{http://hdl.handle.net/10.1093/aob/mcu084}{doi:10.1093/aob/mcu084},
data available at \url{http://hdl.handle.net/2142/49963}).

<<>>=
mydata <- readHMC("HapMapMsiSubset1.hmc.txt",
                  possiblePloidies = list(2, c(2,2)))
@

We can iteratively estimate genotype probabilities assuming 
Hardy-Weinberg equilibrium.  The argument \texttt{tol} is set to a higher
value than the default here in order to help the tutorial run more quickly.

<<>>=
mydataHWE <- IterateHWE(mydata, tol = 1e-3)
@

Let's take a look at allele frequencies:

<<fig=TRUE>>=
hist(mydataHWE$alleleFreq, breaks = 20)
@

There are bumps around 0.4 and 0.6, which may be artefactual due to paralogs
in the dataset.

We can do a different genotype probability estimation that models population
structure and variation in allele frequencies among populations.  We don't
need to specify populations, since principal components analysis is used to
assess population structure assuming an isolation-by-distance model, with
gradients of gene flow across many groups of individuals.  This dataset 
includes a very broad sampling of \textit{Miscanthus} across Asia, so it
is very appropriate to model population structure in this case.

<<>>=
mydataPopStruct <- IteratePopStruct(mydata)
@

The allele frequency bumps have somewhat gone away:

<<fig=TRUE>>=
hist(mydataPopStruct$alleleFreq, breaks = 20)
@

Here's some of the population structure that was used for modeling
allele frequencies:

<<fig=TRUE>>=
plot(mydataPopStruct$PCA[,1], mydataPopStruct$PCA[,2],
     xlab = "PC axis 1", ylab = "PC axis 2")
@

And here's an example of allele frequency varying across the environment.
Allele frequencies were estimated for each taxon, and are stored in the
\texttt{\$alleleFreqByTaxa} slot.

<<fig=TRUE>>=
myallele <- 11
freqcol <- rainbow(101)[round(mydataPopStruct$alleleFreqByTaxa[,myallele] * 100) + 1]
plot(mydataPopStruct$PCA[,1], mydataPopStruct$PCA[,2],
     xlab = "PC axis 1", ylab = "PC axis 2", pch = 21,
     bg = freqcol)
@

As before, we can export the weighted mean genotypes for downstream analysis.

<<>>=
wmgenoPopStruct <- GetWeightedMeanGenotypes(mydataPopStruct)
wmgenoPopStruct[1:10,1:5]
@


\end{document}
