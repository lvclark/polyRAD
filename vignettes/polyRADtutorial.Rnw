% \VignetteIndexEntry{polyRAD tutorial}
% \VignettDepends{polyRAD}

\documentclass{article}

\usepackage{hyperref}

\title{polyRAD tutorial}
\date{\today}
\author{Lindsay V. Clark \\ University of Illinois, Urbana-Champaign}

\begin{document}
\SweaveOpts{concordance=TRUE}

\maketitle

\section{Introduction}

polyRAD is an R package that assists with genotype calling from DNA sequence
datasets such as genotyping-by-sequencing (GBS) or restriction site-associated
DNA sequencing (RAD) in polyploids and diploids.  Genotype likelihoods are 
estimated from allelic read
depth, genotype prior probabilities are estimated from population parameters,
and then genotype posterior probabilities are estimated from likelihoods and
prior probabilities.  Posterior probabilities can be used directly in 
downstream analysis, converted to weighted mean genotypes for analyses
of additive genetic effects, or used for export of the most probable genotypes
for analyses that require discrete genotypic data.

Analyses in polyRAD center around objects of an S3 class called ``RADdata''.
A single ``RADdata'' object contains the entire dataset of read depth and 
locus information, as well as parameters that are estimated during the
course of analysis.

\section{Summary of available functions}

For any function named in this section, see its help page for more information.
(For example by typing \texttt{?VCF2RADdata} into the R console.)

Several functions are available for import of read depth data and (optionally)
alignment information into a RADdata object:

\begin{itemize}
\item \texttt{VCF2RADdata}
\item \texttt{readTagDigger}
\item \texttt{readStacks1}
\item \texttt{readHMC}
\end{itemize}

More generally, the \texttt{RADdata} function is used for constructing RADdata
objects; see the help page for that function for more information on what 
data are needed.

Several pipelines are available for genotype estimation, depending on how the 
population is structured (i.e. what the genotype prior probabilities should be.):

\begin{itemize}
\item \texttt{PipelineMapping2Parents}
\item \texttt{IterateHWE}
\item \texttt{IterateHWE\_LD}
\item \texttt{IteratePopStruct}
\item \texttt{IteratePopStructLD}
\end{itemize}

Lastly, for exporting the estimated genotypes to other software:

\begin{itemize}
\item \texttt{ExportGAPIT}
\item \texttt{Export\_rrBLUP\_Amat}
\item \texttt{Export\_rrBLUP\_GWAS}
\item \texttt{Export\_TASSEL\_Numeric}
\end{itemize}

If you need continuous numerical genotypes exported in some other format, see 
\texttt{GetWeightedMeanGenotypes}.  Also, \texttt{GetLikelyGen} returns the 
most likely genotypes for a single sample.

\section{Estimating genotype probabilities in a mapping population}

In this example, we'll import some data from an F1 mapping population
of \emph{Miscanthus sinensis} that were output by the 
\href{https://doi.org/10.1371/journal.pgen.1003215}{UNEAK} pipeline.
These data are from a study by Liu \emph{et al.} 
(2015; \href{http://dx.doi.org/10.1111/gcbb.12275}{doi:10.1111/gcbb.12275};
data available at \url{http://hdl.handle.net/2142/79522}), and can be
found in the ``extdata'' folder of the polyRAD installation.
\emph{Miscanthus} is an ancient tetraploid that has undergone diploidization.
Given the ability of the UNEAK pipeline to filter paralogs, we expect most
loci to behave in a diploid fashion, but some may behave in an allotetraploid
fashion.

We'll start by loading polyRAD and importing the data into a ``RADdata''
object.  The \texttt{possiblePloidies} argument indicates the expected
inheritance modes: diploid (2) and allotetraploid (2 2).

<<>>=
library(polyRAD)
maphmcfile <- system.file("extdata", "ClareMap_HapMap.hmc.txt", 
                          package = "polyRAD")

mydata <- readHMC(maphmcfile,
                  possiblePloidies = list(2, c(2, 2)))
mydata
@

We can view the imported taxa names (subsetted here for space).

<<>>=
GetTaxa(mydata)[c(1:10,293:299)]
@

All names starting with ``Map'' are progeny.  ``Kaskade-Justin'' and
``Zebrinus-Justin'' are the parents.  ``IGR-2011-001'', ``p196-150A-c'',
and ``p877-348-b'' aren't part of the population, but were doubled
haploid lines that were used to screen for paralogous markers.  We can
tell polyRAD which taxa are the parents; since this is an F1 population
it doesn't matter which is ``donor'' and which is ``recurrent''.

<<>>=
mydata <- SetDonorParent(mydata, "Kaskade-Justin")
mydata <- SetRecurrentParent(mydata, "Zebrinus-Justin")
@

The next thing we'll want to do is add our genomic alignment data.  For this
dataset, we have alignment data stored in a CSV file, also in the ``extdata''
directory of the polyRAD installation.  We'll add it to the \texttt{locTable}
slot of our \texttt{RADdata} object.  Be sure to name the new columns
``Chr'' and ``Pos''.

<<>>=
alignfile <- system.file("extdata", "ClareMap_alignments.csv", 
                         package = "polyRAD")

aligndata <- read.csv(alignfile, row.names = 1)
head(aligndata)

mydata$locTable$Chr <- aligndata[GetLoci(mydata), 1]
mydata$locTable$Pos <- aligndata[GetLoci(mydata), 2]
head(mydata$locTable)
@

If you don't have alignment data in your own dataset, you can still use
the pipeline described here.  Just set \texttt{useLinkage = FALSE} in 
the code below.  The advantage of including alignment data is that gentoypes
at linked markers are used for imputing missing or correcting erroneous
genotypes.

Now we can run the pipeline.
We'll specify that we don't want to include the parents or doubled haploid
lines in the estimation of allele frequencies or evaluation of genotype
frequenecies (\texttt{excludeTaxa} argument). The
\texttt{allowedDeviation} argument indicates how different the apparent
allele frequency (based on read depth ratios) can be from an expected
allele frequency (determined based on ploidy and mapping population type) 
and still be classified as that allele frequency. The default settings assume an
F1 population, but the population type can be adjusted using the
\texttt{n.gen.backcrossing}, \texttt{n.gen.intermating}, and
\texttt{n.gen.selfing} arguments.


<<>>=
mydata <- PipelineMapping2Parents(mydata, 
                                  freqExcludeTaxa = c("Kaskade-Justin", 
                                                      "Zebrinus-Justin",
                                                     "IGR-2011-001",
                                                     "p196-150A-c", 
                                                     "p877-348-b"),
                                  freqAllowedDeviation = 0.06,
                                  useLinkage = TRUE)
@

We can examine the allele frequencies.
Allele frequencies that fall outside of the expected ranges will be 
recorded as they were estimated from read depth.

<<>>=
table(mydata$alleleFreq)
@

Genotype likelihood is also stored in the object for each possible
genotype at each locus, taxon, and ploidy.  This is the probability
of seeing the observed distribution of reads.

<<>>=
mydata$alleleDepth[3,11:20]
mydata$genotypeLikelihood[[1]][,3,11:20]
mydata$genotypeLikelihood[[2]][,3,11:20]
@

Above, for one individal (Map1-001), we see its read depth at the
first ten alleles (first five loci), followed by the genotype likelihoods
under diploid and tetraploid models.  For example, at locus TP26698, 
heterozygosity is the most likely state, although there is a chance that
this individual is homozygous for allele 1 and the one read of allele 0
was due to contamination.  If this locus is allotetraploid, it is most
likely that there is one copy of allele 0 and three copies of allele 1.
Other loci have higher depth and as a result there is less uncertainty
in the genotype, particularly for the diploid model.

The prior genotype probabilities (expected genotype distributions) are also
stored in the object for each possible ploidy.  These distributions are estimated based
on the most likely parent genotypes.  Low confidence parent genotypes
can be ignored by increasing the \texttt{minLikelihoodRatio} argument to
\texttt{PipelineMapping2Parents}.

<<>>=
mydata$priorProb[[1]][,11:20]
mydata$priorProb[[2]][,11:20]
@

Here we see some pretty big differences under the diploid and
allotetrapliod models.  For example, if TP24805 is behaving in a diploid
fashion we expect F2-like segregation since both parents were 
heterozygous.  However, if TP24805 is behaving in an allotetraploid
fashion, we expect that both parents are homozygous at differing 
paralogous loci, resulting in no segregation.

Now we want to determine which ploidy is the best fit for each locus.
This is done by comparing genotype prior probabilities to
genotype likelihoods and estimating a $\chi^2$ statistic.  Lower
values indicate a better fit.

<<>>=
mydata$ploidyChiSq[,11:20]
@

We can make a plot to get an overall sense of how well the markers
fit the diploid versus tetraploid model.

<<fig=TRUE>>=
plot(mydata$ploidyChiSq[1,], mydata$ploidyChiSq[2,], 
     xlab = "Chi-squared for diploid model",
     ylab = "Chi-squared for tetraploid model")
abline(a = 0, b = 1, col = "red")
@

Alleles above the red line fit the diploid model better, and alleles
below the red line fit the tetraploid model better.  In this case it
looks like everything is diploid with fairly high confidence.

Now we'll examine the posterior genotype probabilities.  These are still
estimated separately for each ploidy.

<<>>=
mydata$posteriorProb[[1]][,3,11:20]
mydata$posteriorProb[[2]][,3,11:20]
@

We can export the results for use in downstream analysis.  The function
below weights possible ploidies for each allele based on the results
in \texttt{mydata\$ploidyChiSq}, and for each taxon outputs a continuous,
numerical genotype that is the mean of all possible genotypes weighted
by genotype posterior probabilities.  By default, one allele per locus
is discarded in order to avoid mathematical singularities in downstream
analysis.  The continuous genotypes also range from zero to one by default,
which can be changed with the \texttt{minval} and \texttt{maxval} arguments.

<<>>=
mywm <- GetWeightedMeanGenotypes(mydata)
mywm[c(297,2:6), 6:10]
@

Note that the parent weighted mean genotypes were estimated using 
gentoype likelihood only, ignoring the priors set for the progeny.  In 
some places they may not match the progeny genotypes, indicating a
likely error in parental genotype calling.

\section{Estimating genotype probabilities in a diversity panel}

Pipelines in polyRAD for processing a diversity panel (i.e. a germplasm
collection, a set of samples collected in the wild, or a panel for
genome-wide association analysis or genomic prediction) use iterative
algorithms.  Essentially, allele frequencies are re-estimated with each
iteration until convergence is reached.

Here we'll import a RAD-seq dataset from a large collection of wild and
ornamental \textit{Miscanthus} from Clark \textit{et al.} (2014;
\href{http://hdl.handle.net/10.1093/aob/mcu084}{doi:10.1093/aob/mcu084}.

Since the data are in VCF format, we will need the Bioconductor package
VariantAnnotation to load them.  See 
\url{https://bioconductor.org/packages/release/bioc/html/VariantAnnotation.html}
for installation instructions.

<<>>=
library(VariantAnnotation)

myVCF <- system.file("extdata", "Msi01genes.vcf", package = "polyRAD")
@

For your own VCF files, you will want to compress and index them before
reading them.  This has already been done for the file supplied with
polyRAD, but here is how you would do it:

<<eval=FALSE>>=
mybg <- bgzip(myVCF)
indexTabix(mybg, format = "vcf")
@

Now we can make our \texttt{RADdata} object.  Because this is a small example
dataset, we are setting \texttt{expectedLoci} and \texttt{expectedAlleles} to
very low values; in a real dataset they should reflect how much data you are
actually expecting.  It is best to slightly overestimate the number of expected
alleles and loci.

<<>>=
mydata <- VCF2RADdata(myVCF, possiblePloidies = list(2, c(2,2)),
                      expectedLoci = 100, expectedAlleles = 500)
mydata
@

We can iteratively estimate genotype probabilities assuming 
Hardy-Weinberg equilibrium.  The argument \texttt{tol} is set to a higher
value than the default here in order to help the tutorial run more quickly.

<<>>=
mydataHWE <- IterateHWE(mydata, tol = 1e-3)
@

Let's take a look at allele frequencies:

<<fig=TRUE>>=
hist(mydataHWE$alleleFreq, breaks = 20)
@

We can do a different genotype probability estimation that models population
structure and variation in allele frequencies among populations.  We don't
need to specify populations, since principal components analysis is used to
assess population structure assuming an isolation-by-distance model, with
gradients of gene flow across many groups of individuals.  This dataset 
includes a very broad sampling of \textit{Miscanthus} across Asia, so it
is very appropriate to model population structure in this case.

<<>>=
mydataPopStruct <- IteratePopStruct(mydata, nPcsInit = 8)
@

Allele frequency estimates have changed slightly:

<<fig=TRUE>>=
hist(mydataPopStruct$alleleFreq, breaks = 20)
@

Here's some of the population structure that was used for modeling
allele frequencies (fairly weak in this case because so few markers
were used):

<<fig=TRUE>>=
plot(mydataPopStruct$PCA[,1], mydataPopStruct$PCA[,2],
     xlab = "PC axis 1", ylab = "PC axis 2")
@

And here's an example of allele frequency varying across the environment.
Allele frequencies were estimated for each taxon, and are stored in the
\texttt{\$alleleFreqByTaxa} slot.

<<fig=TRUE>>=
myallele <- 1
freqcol <- rainbow(101)[round(mydataPopStruct$alleleFreqByTaxa[,myallele] * 100) + 1]
plot(mydataPopStruct$PCA[,1], mydataPopStruct$PCA[,2],
     xlab = "PC axis 1", ylab = "PC axis 2", pch = 21,
     bg = freqcol)
@

As before, we can export the weighted mean genotypes for downstream analysis.

<<>>=
wmgenoPopStruct <- GetWeightedMeanGenotypes(mydataPopStruct)
wmgenoPopStruct[1:10,1:5]
@

If you expect that your species has high linkage disequilibrium, the functions
\texttt{IterateHWE\_LD} and \texttt{IteratePopStructLD} behave like 
\texttt{IterateHWE} and \texttt{IteratePopStruct}, respectively, but also
update priors based on genotypes at linked loci.

\end{document}
