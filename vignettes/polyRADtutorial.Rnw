% \VignetteIndexEntry{polyRAD tutorial}
% \VignettDepends{polyRAD}

\documentclass{article}

\usepackage{hyperref}

\title{polyRAD tutorial}
\date{\today}
\author{Lindsay V. Clark \\ University of Illinois, Urbana-Champaign}

\begin{document}
\SweaveOpts{concordance=TRUE}

\maketitle

\section{Introduction}

polyRAD is an R package that assists with genotype calling from DNA sequence
datasets such as genotyping-by-sequencing (GBS) or restriction site-associated
DNA sequencing (RAD) in polyploids and diploids.  Genotype likelihoods are 
estimated from allelic read
depth, genotype prior probabilities are estimated from population parameters,
and then genotype posterior probabilities are estimated from likelihoods and
prior probabilities.  Posterior probabilities can be used directly in 
downstream analysis, converted to weighted mean genotypes for analyses
of additive genetic effects, or used for export of the most probable genotypes
for analyses that require discrete genotypic data.

Analyses in polyRAD center around objects of an S3 class called ``RADdata''.
A single ``RADdata'' object contains the entire dataset of read depth and 
locus information, as well as parameters that are estimated during the
course of analysis.

\section{Estimating genotype probabilities in a mapping population}

In this example, we'll import some data from an F1 mapping population
of \emph{Miscanthus sinensis} that were output by the 
\href{https://doi.org/10.1371/journal.pgen.1003215}{UNEAK} pipeline.
These data are from a study by Liu \emph{et al.} 
(2015; \href{http://dx.doi.org/10.1111/gcbb.12275}{doi:10.1111/gcbb.12275};
data available at \url{http://hdl.handle.net/2142/79522}), and can be
found in the ``doc'' folder of the polyRAD installation.
\emph{Miscanthus} is an ancient tetraploid that has undergone diploidization.
Given the ability of the UNEAK pipeline to filter paralogs, we expect most
loci to behave in a diploid fashion, but some may behave in an allotetraploid
fashion.

We'll start by loading polyRAD and importing the data into a ``RADdata''
object.  The \texttt{possiblePloidies} argument indicates the expected
inheritance modes: diploid (2) and allotetraploid (2 2).

<<>>=
library(polyRAD)
mydata <- readHMC("HapMapClareMap1subset.hmc.txt",
                  possiblePloidies = list(2, c(2, 2)))
mydata
@

We can view the imported taxa names (subsetted here for space).

<<>>=
GetTaxa(mydata)[c(1:10,293:299)]
@

All names starting with ``Map'' are progeny.  ``Kaskade-Justin'' and
``Zebrinus-Justin'' are the parents.  ``IGR-2011-001'', ``p196-150A-c'',
and ``p877-348-b'' aren't part of the population, but were doubled
haploid lines that were used to screen for paralogous markers.  We can
tell polyRAD which taxa are the parents; since this is an F1 population
it doesn't matter which is ``donor'' and which is ``recurrent''.

<<>>=
mydata <- SetDonorParent(mydata, "Kaskade-Justin")
mydata <- SetRecurrentParent(mydata, "Zebrinus-Justin")
@

Now we can run the pipeline.
We'll specify that we don't want to include the parents or double haploid
lines in the estimation of allele frequencies or evaluation of genotype
freqnecies (\texttt{excludeTaxa} argument). The
\texttt{allowedDeviation} argument indicates how different the apparent
allele frequency (based on read depth ratios) can be from an expected
allele frequency (determined based on ploidy and mapping population type) 
and still be classified as that allele frequency. The default settings assume an
F1 population, but the population type can be adjusted using the
\texttt{n.gen.backcrossing}, \texttt{n.gen.intermating}, and
\texttt{n.gen.selfing} arguments.


<<>>=
mydata <- PipelineMapping2Parents(mydata, 
                                  freqExcludeTaxa = c("Kaskade-Justin", 
                                                      "Zebrinus-Justin",
                                                     "IGR-2011-001",
                                                     "p196-150A-c", 
                                                     "p877-348-b"),
                                  freqAllowedDeviation = 0.06)
@

We can examine the allele frequencies.
Allele frequencies that fall outside of the expected ranges will be 
recorded as \texttt{NA}.

<<>>=
table(mydata$alleleFreq)
@

Genotype likelihood is also stored in the object for each possible
genotype at each locus, taxon, and ploidy.  This is the probability
of seeing the observed distribution of reads.

<<>>=
mydata$alleleDepth[3,1:10]
mydata$genotypeLikelihood[[1]][,3,1:10]
mydata$genotypeLikelihood[[2]][,3,1:10]
@

Above, for one individal (Map1-001), we see its read depth at the
first ten alleles (first five loci), followed by the genotype likelihoods
under diploid and tetraploid models.  For example, at locus TP29 we see
that homozygosity for allele 0 is the most likely, although heterozygosity
is not impossible, and homozygosity for allele 1 could happen in the very,
very unlikely event that all eight of the reads are due to contamination.
At TP37, heterozygosity is by far the most likely state, and if there
is tetraploidy there are probably one or two copies of allele 0 rather than
three copies.

The prior genotype probabilities (expected genotype distributions) are also
stored in the object for each possible ploidy.  These distributions are estimated based
on the most likely parent genotypes.  Low confidence parent genotypes
can be ignored by increasing the \code{minLikelihoodRatio} argument to
\code{PipelineMapping2Parents}.

<<>>=
mydata$priorProb[[1]][,1:10]
mydata$priorProb[[2]][,1:10]
@

Here we see some pretty big differences under the diploid and
allotetrapliod models.  For example, if TP29 is behaving in a diploid
fashion we expect F2-like segregation since both parents were 
heterozygous.  However, if TP29 is behaving in an allotetraploid
fashion, we expect that both parents are homozygous at differing 
paralogous loci, resulting in no segregation.

Now we want to determine which ploidy is the best fit for each locus.
This is done by comparing genotype prior probabilities to
genotype likelihoods and estimating a $\chi^2$ statistic.  Lower
values indicate a better fit.

<<>>=
mydata$ploidyChiSq[,1:10]
@

We can make a plot to get an overall sense of how well the markers
fit the diploid versus tetraploid model.

<<fig=TRUE>>=
plot(mydata$ploidyChiSq[1,], mydata$ploidyChiSq[2,], 
     xlab = "Chi-squared for diploid model",
     ylab = "Chi-squared for tetraploid model")
abline(a = 0, b = 1, col = "red")
@

Alleles above the red line fit the diploid model better, and alleles
below the red line fit the tetraploid model better.

Now we'll examine the posterior genotype probabilities.  These are still
estimated separately for each ploidy.

<<>>=
mydata$posteriorProb[[1]][,3,1:10]
mydata$posteriorProb[[2]][,3,1:10]
@

We can export the results for use in downstream analysis.  The function
below weights possible ploidies for each allele based on the results
in \texttt{mydata\$ploidyChiSq}, and for each taxon outputs a continuous,
numerical genotype that is the mean of all possible genotypes weighted
by genotype posterior probabilities.  By default, one allele per locus
is discarded in order to avoid mathematical singularities in downstream
analysis.  The continuous genotypes also range from zero to one by default,
which can be changed with the \texttt{minval} and \texttt{maxval} arguments.

<<>>=
mywm <- GetWeightedMeanGenotypes(mydata)
mywm[3:6, 1:10]
@

Note that the parent weighted mean genotypes are not necessarily correct,
since they were estimated using the genotype priors for the progeny.
We can view parent genotypes with \texttt{GetLikelyGen}, which was used
internally by \texttt{AddGenotypePriorProb\_Mapping2Parents} to estimate
the parent genotypes.

<<>>=
kaskadeGen <- GetLikelyGen(mydata, "Kaskade-Justin")
zebrinusGen <- GetLikelyGen(mydata, "Zebrinus-Justin")
kaskadeGen[,1:10]
zebrinusGen[,1:10]
@

To subset parent genotypes in order to match the progeny genotypes:

<<>>=
kaskadeGenSubset <- sweep(kaskadeGen[,-OneAllelePerMarker(mydata)],
                          1, c(2,4), "/")
zebrinusGenSubset <- sweep(zebrinusGen[,-OneAllelePerMarker(mydata)],
                          1, c(2,4), "/")
kaskadeGenSubset[,1:10]
zebrinusGenSubset[,1:10]
@


\end{document}
